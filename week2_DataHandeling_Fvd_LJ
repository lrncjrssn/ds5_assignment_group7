## =====================
## OPDRACHT 1
## =====================
# taken Felix: CSV inlezen + totaal/average berekenen
# taken Laurence: records filteren, rapport genereren & printen

import csv
from typing import List, Dict, Tuple

# ----- Felix -----
def read_csv(file_path: str) -> List[Dict[str, str]]:
    """
    Functie om CSV-bestand te lezen en records op te slaan
    in een lijst van dictionaries.
    Gemaakt door Felix
    """
    records = []
    with open(file_path, "r") as file:
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            records.append(row)
    return records

def calculate_total_and_average(records: List[Dict[str, str]]) -> Tuple[float, float]:
    """
    Functie om het totaal en gemiddelde te berekenen van alle cijfers.
    Gemaakt door Felix
    """
    grades = [float(record["Grade"]) for record in records]
    total = sum(grades)
    average = total / len(grades) if grades else 0.0
    return total, average

# ----- Laurence -----
def filtered_records(records, threshold=80.0):
    return [record for record in records if float(record['Grade']) >= threshold]    

def print_filtered_records(records, threshold=80.0): 
    """ik heb 1 functie gemaakt voor het filteren en printen van records, gemaakt door Laurence"""
    filtered = [record for record in records if float(record['Grade']) >= threshold]
    for record in filtered:
        print(f"Name: {record['Name']}")
        print(f"Grade: {record['Grade']}")
        print("--------------------")
    return filtered


## =====================
## OPDRACHT 2
## =====================
# taken Felix: plot_mandelbrot
# taken Laurence: coordinaten + diverging index

import numpy as np
import matplotlib.pyplot as plt

# ----- Laurence -----
def coordinaten(width: float):
    """ Gemaakt door Laurence maakt de x en y coordinaten voor alle pixels """
    x_min = -1.5
    x_max = 0.5
    y_min = -1.0
    y_max = 1.0

    x_lijst = np.linspace(x_min, x_max, width)
    y_lijst = np.linspace(y_min, y_max, width)

    X, Y = np.meshgrid(x_lijst, y_lijst)
    return X, Y

def diverging_index(x: float, y: float) -> int:
    """gemaakt door Laurence, berekent de diverging index"""
    c = complex(x, y)
    a = 0
    i = 0
    while abs(a) < 2 and i < 100:
        a = a**2 + c
        i += 1
    return i if i < 100 else 0

# ----- Felix -----
def plot_mandelbrot(divergence_array: np.ndarray) -> None:
    """
    Maakt een visualisatie van de Mandelbrot set met kleuren 
    gebaseerd op de diverging index en toont de plot.
    Gemaakt door Felix
    """
    plt.figure(figsize=(6,6))
    plt.imshow(divergence_array, cmap="plasma", extent=[-1.5, 0.5, -1, 1])
    plt.colorbar(label="Diverging index")
    plt.title("Mandelbrot Set")
    plt.xlabel("Re(z)")
    plt.ylabel("Im(z)")
    plt.show()


## =====================
## OPDRACHT 3.1
## =====================
# Laurence -> functies maken voor het genereren van een ster grafiek, nieuwe nodes toevoegen en een grafiek genereren

import networkx as nx
import random

def maak_ster(k: int):
    """gemaakt door Laurence, maakt een ster grafiek met k + 1 punten"""
    g = nx.Graph()
    g.add_node(0) 
    for i in range(1, k + 1):
        g.add_node(i)
        g.add_edge(0, i)
    return g

def nieuwe_node(g: nx.Graph, m: int):
    """gemaakt door Laurence, voegt een nieuwe node toe aan de grafiek"""
    new_node = max(g.nodes()) + 1
    bestaande_nodes = list(g.nodes())
    grades = [g.degree(n) for n in bestaande_nodes]
    som_grades = sum(grades)
    kansen = [grade / som_grades for grade in grades]

    gekozen_nodes = np.random.choice(bestaande_nodes, size=m, replace=False, p=kansen)
    gekozen_nodes = list(set(gekozen_nodes))

    while len(gekozen_nodes) < m:
        extra_node = random.choice(bestaande_nodes)
        if extra_node not in gekozen_nodes:
            gekozen_nodes.append(extra_node)

    g.add_node(new_node)
    for n in gekozen_nodes: 
        g.add_edge(new_node, n)
    return g

def genereer_grafiek(k: int, n: int, m: int):
    """gemaakt door Laurence, genereert een grafiek met n nodes en m edges per nieuwe node"""
    g = maak_ster(m)

    while len(g.nodes()) < n:
        g = nieuwe_node(g, m)

    return g
    

## =====================
## OPDRACHT 3.2
## =====================
# Laurence -> aanpassen van eerder gemaakte functies voor directed graphs 

def maak_star_graph_directed(k: int) -> nx.DiGraph:
    """gemaakt door Laurence, maakt een directed star graph met k + 1 punten""" 
    G = nx.DiGraph()
    center = 0
    for i in range(1, k+2):
        G.add_edge(center, i) 
    return G

def nieuwe_node_directed(G: nx.DiGraph, M: int) -> nx.DiGraph:
    """gemaakt door Laurence, voegt een nieuwe node toe aan de directed graph met M edges"""
    nieuwe_node = max(G.nodes()) + 1
    G.add_node(nieuwe_node)
    
    degrees = [G.in_degree(n)+1 for n in G.nodes() if n != nieuwe_node]
    nodes = [n for n in G.nodes() if n != nieuwe_node]
    gekozen = random.choices(nodes, weights=degrees, k=M)
    
    for target in gekozen:
        G.add_edge(nieuwe_node, target) 
    
    return G

def genereer_network_directed(k: int, N: int, M: int) -> nx.DiGraph:
    """gemaakt door Laurence, genereert een directed graph met N nodes en M edges per nieuwe node"""
    G = maak_star_graph_directed(k)
    while len(G.nodes()) < N:
        G = nieuwe_node_directed(G, M)
    return G


## =====================
## TEST / AANROEPEN
## =====================
if __name__ == "__main__":
    # Opdracht 1 testen
    dummy_csv = "grades.csv"
    with open(dummy_csv, "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=["Name","Grade"])
        writer.writeheader()
        writer.writerow({"Name":"Alice","Grade":"95"})
        writer.writerow({"Name":"Bob","Grade":"78"})
        writer.writerow({"Name":"Charlie","Grade":"88"})

    print("=== OPDRACHT 1 ===")
    records = read_csv(dummy_csv)
    totaal, gemiddeld = calculate_total_and_average(records)
    print(f"Totaal: {totaal}, Gemiddelde: {gemiddeld}")
    print_filtered_records(records)

    # Opdracht 2 testen
    print("\n=== OPDRACHT 2 ===")
    breedte = 200
    X, Y = coordinaten(breedte)
    mandel_array = np.zeros((breedte, breedte))
    for i in range(breedte):
        for j in range(breedte):
            mandel_array[i,j] = diverging_index(X[i,j], Y[i,j])
    plot_mandelbrot(mandel_array)

    # Opdracht 3.1 testen
    print("\n=== OPDRACHT 3.1 ===")
    g = genereer_grafiek(k=3, n=10, m=2)
    print("Nodes:", g.nodes())
    print("Edges:", g.edges())

    # Opdracht 3.2 testen
    print("\n=== OPDRACHT 3.2 ===")
    G_dir = genereer_network_directed(k=2, N=10, M=2)
    print("Directed Nodes:", G_dir.nodes())
    print("Directed Edges:", G_dir.edges())
